; All credit to KIP IRVINE for the Randomize, Random32, and RandomRange Procedures
; I have moved those procedures to this include file for compatibility with the MASM32 Libraries

	include \masm32\include\windows.inc
	include \masm32\include\user32.inc
	include \masm32\include\gdi32.inc
	include \masm32\include\kernel32.inc
	include \masm32\include\masm32.inc
	
	includelib \masm32\lib\user32.lib
	includelib \masm32\lib\gdi32.lib
	includelib \masm32\lib\kernel32.lib
	includelib \masm32\lib\masm32.lib
.data
sysTime SYSTEMTIME <> ; used to seed random number generator.

; access grid cells using the following: [base + index],
; where base is held in a base register
; and index is held in an index register.
; 48 is the ascii character for zero,
; by default cells in the grid will consist of zero.
grid	BYTE 9 DUP(48)
rowSize	= ($ - grid)
		BYTE 9 DUP(48)
		BYTE 9 DUP(48)
		BYTE 9 DUP(48)
		BYTE 9 DUP(48)
		BYTE 9 DUP(48)
		BYTE 9 DUP(48)
		BYTE 9 DUP(48)
		BYTE 9 DUP(48)

.code

; Places 10 mines randomly throughout the grid.
; Uses ecx for loop count, esi for location of grid, and eax for random number generation.
PlaceMines PROC uses ecx esi eax
	mov ecx, 10
	MineLayer:
		mov esi, offset grid
		mov eax, 81
		call RandomRange
		add esi, eax
		mov bl, [esi]
		cmp bl, 42
		je MineLayer
		call IncCells
		mov eax, 42
		mov [esi], al
		loop MineLayer
	ret
PlaceMines ENDP

; This procedure is called every time a new mine is placed, 
; and it will increment the value of surrounding cells by one.
; It also checks if the cell is at the edge of the grid, using division.
; If the cell is located at an edge, it will increment surroundings accordingly.
; When this procedure is called, esi should contain the location 
; of the center cell, which will contain a mine.
; eax will have the value between 0 and 80 generated by random range, 
; essentially it is the index of the cell.
IncCells PROC uses ebx edx
	mov bl, 9
	div bl				; puts quotient of esi / 9 into al and remainder into ah.
	mov edx, 1			; Required to increment cells by reference
	
		cmp al, 0
		je Lower	
	Upper:
		mov bl, [esi-9]
		cmp bl, 42
		je Lower
		add [esi-9], dl
	
	Lower:
		cmp al, 8
		je Left
		mov bl, [esi+9]
		cmp bl, 42
		je Left
		add [esi+9], dl
	
	Left:
		cmp ah, 0
		je Right
		
		cmp al, 0
		je Left2
		mov bl, [esi-10]
		cmp bl, 42
		je Left2
		add [esi-10], dl
		
		Left2:
		mov bl, [esi-1]
		cmp bl, 42
		je Left3
		add [esi-1], dl
		
		Left3:
		cmp al, 8
		je Right
		mov bl, [esi+8]
		cmp bl, 42
		je Right
		add [esi+8], dl
		
	
	Right:
		cmp ah, 8
		je Done
		
		cmp al,0
		je Right2
		mov bl, [esi-8]
		cmp bl, 42
		je Right2
		add [esi-8], dl
		
		Right2:
		mov bl, [esi+1]
		cmp bl, 42
		je Right3
		add [esi+1], dl
		
		Right3:
		cmp al, 8
		je Done
		mov bl, [esi+10]
		cmp bl, 42
		je Done
		add [esi+10], dl
	
	Done:
	ret
IncCells ENDP

;--------------------------------------------------------
Randomize PROC
;
; Re-seeds the random number generator with the current time
; in seconds. Calls GetSystemTime, which is accurate to 10ms.
; Receives: nothing
; Returns: nothing
; Last update: 09/06/2002
; AUTHOR: KIP IRVINE
;--------------------------------------------------------
	  pushad

	  INVOKE GetSystemTime,OFFSET sysTime
	  movzx eax,sysTime.wMilliseconds
	  mov   seed,eax

	  popad
	  ret
Randomize ENDP

;--------------------------------------------------------------
RandomRange PROC
;
; Returns an unsigned pseudo-random 32-bit integer
; in EAX, between 0 and n-1. Input parameter:
; EAX = n.
; Last update: 09/06/2002
; AUTHOR: KIP IRVINE
;--------------------------------------------------------------
	 push  ebx
	 push  edx

	 mov   ebx,eax  ; maximum value
	 call  Random32 ; eax = random number
	 mov   edx,0
	 div   ebx      ; divide by max value
	 mov   eax,edx  ; return the remainder

	 pop   edx
	 pop   ebx

	 ret
RandomRange ENDP

;--------------------------------------------------------------
Random32  PROC
;
; Generates an unsigned pseudo-random 32-bit integer
;   in the range 0 - FFFFFFFFh.
; Receives: nothing
; Returns: EAX = random integer
; Last update: 7/11/01
; AUTHOR: KIP IRVINE
;--------------------------------------------------------------
.data
seed  DWORD 1
.code
	  push  edx
	  mov   eax, 343FDh
	  imul  seed
	  add   eax, 269EC3h
	  mov   seed, eax    ; save the seed for the next call
	  ror   eax,8        ; rotate out the lowest digit (10/22/00)
	  pop   edx

	  ret
Random32  ENDP


.data
hButtons DWORD 81 DUP(?)
gridIndex DWORD ?
gridX WORD ?
gridY WORD ?

; all existing indices fall in range between 0 and 80.
; therefore, if encountered 81, it means the end of visited indices
visited BYTE 81 DUP(81)

.code
removeButtons PROC ; uses wParam in EAX register
	mov edi, OFFSET hButtons
	mov edx, [edi+eax]
	
	mov esi, OFFSET grid
	mov ebx, 4
	div	bl
	movzx eax, al
	mov ecx, [esi+eax]
	ret
removeButtons ENDP

; ____________________________________
indexToXY PROC uses EAX EDX
; this procedure converts a grid index
; into X & Y coordinates.
; Uses: EAX, EDX
; ____________________________________
	mov eax, gridIndex
	mov edx, rowSize
	div dx ; AX = quotient (X), DX = remainder (Y)
	mov gridX, ax
	mov gridY, dx
	ret
indexToXY ENDP

; _______________________
xyToIndex PROC uses EAX
; this procedure converts
;  X & Y into grid index.
; Uses: EAX (X), EBX (Y)
; _______________________
	mov ecx, rowSize
	mul cl          ; x * row size ->
	add eax, ebx    ; result + y = index 
	mov gridIndex, eax
	ret
xyToIndex ENDP

; __________________________________________
addSurroundingCells PROC
; this procedure adds surrounding cells
; into the stack and keeps the total number.
; Uses: ECX, stack
; __________________________________________
	; TOP-LEFT CELL ********************************************************
	movzx eax, gridX-1
	movzx ebx, gridY-1
	cmp eax, 0
	jl cell1           ; skip to next cell if x < 0
	cmp eax, 8
	jg cell1           ; skip to next cell if x > 8
	cmp ebx, 0
	jl cell1           ; skip to next cell if y < 0
	cmp ebx, 8
	jg cell1           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je cell1           ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack
	push gridIndex
	inc ecx
	
cell1: ; TOP-MIDDLE CELL ***************************************************
	movzx eax, gridX-1
	movzx ebx, gridY
	cmp eax, 0
	jl cell2           ; skip to next cell if x < 0
	cmp eax, 8
	jg cell2           ; skip to next cell if x > 8
	cmp ebx, 0
	jl cell2           ; skip to next cell if y < 0
	cmp ebx, 8
	jg cell2           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je cell2           ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack
	push gridIndex
	inc ecx

cell2: ; TOP-RIGHT CELL ****************************************************
	movzx eax, gridX-1
	movzx ebx, gridY+1
	cmp eax, 0
	jl cell3           ; skip to next cell if x < 0
	cmp eax, 8
	jg cell3           ; skip to next cell if x > 8
	cmp ebx, 0
	jl cell3           ; skip to next cell if y < 0
	cmp ebx, 8
	jg cell3           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je cell3           ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack
	push gridIndex
	inc ecx

cell3: ; LEFT CELL *********************************************************
	movzx eax, gridX
	movzx ebx, gridY-1
	cmp eax, 0
	jl cell4           ; skip to next cell if x < 0
	cmp eax, 8
	jg cell4           ; skip to next cell if x > 8
	cmp ebx, 0
	jl cell4           ; skip to next cell if y < 0
	cmp ebx, 8
	jg cell4           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je cell4           ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack
	push gridIndex
	inc ecx

cell4: ; RIGHT CELL ********************************************************
	movzx eax, gridX
	movzx ebx, gridY+1
	cmp eax, 0
	jl cell5           ; skip to next cell if x < 0
	cmp eax, 8
	jg cell5           ; skip to next cell if x > 8
	cmp ebx, 0
	jl cell5           ; skip to next cell if y < 0
	cmp ebx, 8
	jg cell5           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je cell5           ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack
	push gridIndex
	inc ecx

cell5: ; BOTTOM-LEFT CELL **************************************************
	movzx eax, gridX+1
	movzx ebx, gridY-1
	cmp eax, 0
	jl cell6           ; skip to next cell if x < 0
	cmp eax, 8
	jg cell6           ; skip to next cell if x > 8
	cmp ebx, 0
	jl cell6           ; skip to next cell if y < 0
	cmp ebx, 8
	jg cell6           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je cell6           ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack
	push gridIndex
	inc ecx

cell6: ; BOTTOM-MIDDLE CELL ************************************************
	movzx eax, gridX+1
	movzx ebx, gridY
	cmp eax, 0
	jl cell7           ; skip to next cell if x < 0
	cmp eax, 8
	jg cell7           ; skip to next cell if x > 8
	cmp ebx, 0
	jl cell7           ; skip to next cell if y < 0
	cmp ebx, 8
	jg cell7           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je cell7           ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack
	push gridIndex
	inc ecx

cell7: ; BOTTOM-RIGHT CELL *************************************************
	movzx eax, gridX+1
	movzx ebx, gridY+1
	cmp eax, 0
	jl endProc           ; skip to next cell if x < 0
	cmp eax, 8
	jg endProc           ; skip to next cell if x > 8
	cmp ebx, 0
	jl endProc           ; skip to next cell if y < 0
	cmp ebx, 8
	jg endProc           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je endProc           ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack
	push gridIndex
	inc ecx

endProc:
	ret
addSurroundingCells ENDP

checkVisited PROC
	ret
checkVisited ENDP

visitCell PROC
	ret
visitCell ENDP