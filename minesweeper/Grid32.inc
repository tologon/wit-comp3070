; All credit to KIP IRVINE for the Randomize, Random32, and RandomRange Procedures
; I have moved those procedures to this include file for compatibility with the MASM32 Libraries

	include \masm32\include\windows.inc
	include \masm32\include\user32.inc
	include \masm32\include\gdi32.inc
	include \masm32\include\kernel32.inc
	include \masm32\include\masm32.inc

	includelib \masm32\lib\user32.lib
	includelib \masm32\lib\gdi32.lib
	includelib \masm32\lib\kernel32.lib
	includelib \masm32\lib\masm32.lib
.data
sysTime SYSTEMTIME <> ; used to seed random number generator.

; access grid cells using the following: [base + index],
; where base is held in a base register
; and index is held in an index register.
; 48 is the ascii character for zero,
; by default cells in the grid will consist of zero.
grid	BYTE 9 DUP('0')
rowSize	= ($ - grid)
		BYTE 9 DUP('0')
		BYTE 9 DUP('0')
		BYTE 9 DUP('0')
		BYTE 9 DUP('0')
		BYTE 9 DUP('0')
		BYTE 9 DUP('0')
		BYTE 9 DUP('0')
		BYTE 9 DUP('0')

.code

; PlaceMines places 10 mines randomly throughout the grid.
; INPUT		: N/A
; OUTPUT	: 10 random cells in grid are replaced with an * designating a mine
; USES		: ECX for loop count
;			: ESI for location of grid
;			: EAX for random number generation
PlaceMines PROC uses ecx esi eax
	mov ecx, 10
	MineLayer:
		mov esi, offset grid
		mov eax, 81
		call RandomRange
		add esi, eax
		mov bl, [esi]
		cmp bl, '*'
		je MineLayer
		call IncCells
		mov eax, '*'
		mov [esi], al
		loop MineLayer
	ret
PlaceMines ENDP

; IncCells is Called every time a new mine is placed.
; Increments the value of surrounding cells by one.
; Also checks if the cell is at the edge of the grid, using division.
; If the cell is located at an edge, it will ignore cells that cross boundaries
; INPUT		: EAX will have the cell index (generated by RandomRange) (0-80)
;			: ESI will have the memory location of the mine cell.
; OUTPUT	: grid will be modified so that the value of each cell surrounding
;			: target cell is increased by one.
;			: EAX divided by 9: AH contains column location of the cell (x).
;			: AL contains the row location of the cell (y).
; USES		: EBX is used for division operation,
;			:	and checking values of surrounding cells.
;			: EDX is used to increment cells by reference.
IncCells PROC uses ebx edx
	mov bl, 9
	div bl				; puts quotient of index / 9 into al, remainder into ah
	mov dl, 1

		cmp al, 0		; If target cell is in top row
		je Lower		; Ignore top
	Upper:
		mov bl, [esi-9]
		cmp bl, '*'
		je Lower
		add [esi-9], dl

	Lower:
		cmp al, 8
		je Left
		mov bl, [esi+9]
		cmp bl, '*'
		je Left
		add [esi+9], dl

	Left:
		cmp ah, 0
		je Right

		cmp al, 0
		je Left2
		mov bl, [esi-10]
		cmp bl, '*'
		je Left2
		add [esi-10], dl

		Left2:
		mov bl, [esi-1]
		cmp bl, '*'
		je Left3
		add [esi-1], dl

		Left3:
		cmp al, 8
		je Right
		mov bl, [esi+8]
		cmp bl, '*'
		je Right
		add [esi+8], dl


	Right:
		cmp ah, 8
		je Done

		cmp al,0
		je Right2
		mov bl, [esi-8]
		cmp bl, '*'
		je Right2
		add [esi-8], dl

		Right2:
		mov bl, [esi+1]
		cmp bl, '*'
		je Right3
		add [esi+1], dl

		Right3:
		cmp al, 8
		je Done
		mov bl, [esi+10]
		cmp bl, '*'
		je Done
		add [esi+10], dl

	Done:
	ret
IncCells ENDP

; clearGrid will replace all cells in the grid with a zero.
; Useful for resetting the grid -- call this before placing new mines.
; INPUT	: none
; OUTPUT: the grid array will contain all zeroes (ascii characters, value == 48)
; USES	: eax to store '0' -- value replacing grid bytes.
;		: esi to store location of byte being changed
;		: ecx for loop count (length of grid array)
clearGrid PROC uses eax esi ecx
	mov esi, offset grid
	mov ecx, 81
	mov al, '0'
	wipeGrid:
		mov [esi], al
		inc esi
		loop wipeGrid
	ret
clearGrid ENDP

;--------------------------------------------------------
Randomize PROC
;
; Re-seeds the random number generator with the current time
; in seconds. Calls GetSystemTime, which is accurate to 10ms.
; Receives: nothing
; Returns: nothing
; Last update: 09/06/2002
; AUTHOR: KIP IRVINE
;--------------------------------------------------------
	  pushad

	  INVOKE GetSystemTime,OFFSET sysTime
	  movzx eax,sysTime.wMilliseconds
	  mov   seed,eax

	  popad
	  ret
Randomize ENDP

;--------------------------------------------------------------
RandomRange PROC
;
; Returns an unsigned pseudo-random 32-bit integer
; in EAX, between 0 and n-1. Input parameter:
; EAX = n.
; Last update: 09/06/2002
; AUTHOR: KIP IRVINE
;--------------------------------------------------------------
	 push  ebx
	 push  edx

	 mov   ebx,eax  ; maximum value
	 call  Random32 ; eax = random number
	 mov   edx,0
	 div   ebx      ; divide by max value
	 mov   eax,edx  ; return the remainder

	 pop   edx
	 pop   ebx

	 ret
RandomRange ENDP

;--------------------------------------------------------------
Random32  PROC
;
; Generates an unsigned pseudo-random 32-bit integer
;   in the range 0 - FFFFFFFFh.
; Receives: nothing
; Returns: EAX = random integer
; Last update: 7/11/01
; AUTHOR: KIP IRVINE
;--------------------------------------------------------------
.data
seed  DWORD 1
.code
	  push  edx
	  mov   eax, 343FDh
	  imul  seed
	  add   eax, 269EC3h
	  mov   seed, eax    ; save the seed for the next call
	  ror   eax,8        ; rotate out the lowest digit (10/22/00)
	  pop   edx

	  ret
Random32  ENDP


.data
smiley DWORD ?
hButtons DWORD 81 DUP(?)
buttonIndex DWORD ?
gridIndex DWORD ?
gridX WORD ?
gridY WORD ?
currentX WORD ?
currentY WORD ?
validCell BYTE ?

originalEAX DWORD ?

; all existing indices fall in range between 0 and 80.
; therefore, if encountered 100, it means the end of visited indices
visited BYTE 81 DUP(0)

.code
; ________________
removeButtons PROC
; ________________
	mov originalEAX, eax
	call setupAlgorithm ; do initial setup of flood-fill algorithm
	call floodFill      ; recursively call flood-fill using values of gridX and gridY
	mov eax, originalEAX
	ret
removeButtons ENDP

;_______________________________
setupAlgorithm PROC uses ESI EBX
;_______________________________
	mov esi, OFFSET grid
	mov ebx, 4
	div bl
	movzx eax, al      ; grid index
	mov gridIndex, eax ; save grid index
	call indexToXY     ; turn grid index into X and Y values
	ret
setupAlgorithm ENDP

; _____________________________________
floodFill PROC uses EAX EBX ECX EDI EDX
; _____________________________________
	call isValidCell
	cmp validCell, 0
	je endProc
	call visitCell     ; not visited, visit that cell

	call getCellValue
	cmp cl, '*'
	je explosion
	cmp cl, '1'
	jge checkUpperLimit
	cmp cl, '0'
	je openMultipleCells
	jmp endProc

explosion:
	call resetVisitedCells
	call clearButtons
	jmp endProc

checkUpperLimit:
	cmp cl, '8'
	jle openAndStop
	jmp endProc

openAndStop:
	call openCell
	jmp endProc

openMultipleCells:
	call openCell

	call getGridXY
	push ax ; current gridX
	push bx ; current gridY
	call openTopLeft

	pop bx  ; current gridY
	pop ax  ; current gridX
	call storeGridXY
	push ax ; current gridX
	push bx ; current gridY
	call openTopCenter
	
	pop bx  ; current gridY
	pop ax  ; current gridX
	call storeGridXY
	push ax ; current gridX
	push bx ; current gridY
	call openTopRight

	pop bx  ; current gridY
	pop ax  ; current gridX
	call storeGridXY
	push ax ; current gridX
	push bx ; current gridY
	call openLeft
	
	pop bx  ; current gridY
	pop ax  ; current gridX
	call storeGridXY
	push ax ; current gridX
	push bx ; current gridY
	call openBottomLeft

	pop bx  ; current gridY
	pop ax  ; current gridX
	call storeGridXY
	push ax ; current gridX
	push bx ; current gridY
	call openBottomCenter
	
	pop bx  ; current gridY
	pop ax  ; current gridX
	call storeGridXY
	push ax ; current gridX
	push bx ; current gridY
	call openBottomRight

	pop bx  ; current gridY
	pop ax  ; current gridX
	call storeGridXY
	push ax ; current gridX
	push bx ; current gridY
	call openRight

	pop bx  ; current gridY
	pop ax  ; current gridX
	
	jmp endProc

endProc:
	ret
floodFill ENDP

; ______________
isValidCell PROC
; ______________
	mov validCell, 0
	call getGridXY
	cmp al, 0
	jl endProc         ; return if x < 0
	cmp al, 8
	jg endProc         ; return if x > 8
	cmp bl, 0
	jl endProc         ; return if y < 0
	cmp bl, 8
	jg endProc         ; return if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED = 1 or NOT VISITED = 0) in AL
	cmp al, 1          ; if visited index
	je endProc         ; already visited, skip to next cell
	mov validCell, 1   ; this is valid cell, set variable to 1
endProc:
	ret
isValidCell ENDP

; ________________
openTopLeft PROC
; ________________
	call getGridXY
	dec eax
	dec ebx
	call storeGridXY
	call floodFill
	ret
openTopLeft ENDP

; ________________
openTopCenter PROC
; ________________
	call getGridXY
	dec eax
	call storeGridXY
	call floodFill
	ret
openTopCenter ENDP

; ________________
openTopRight PROC
; ________________
	call getGridXY
	dec eax
	inc ebx
	call storeGridXY
	call floodFill
	ret
openTopRight ENDP

; ___________
openLeft PROC
; ___________
	call getGridXY
	dec ebx
	call storeGridXY
	call floodFill
	ret
openLeft ENDP

; ______________
openBottomLeft PROC
; ______________
	call getGridXY
	inc eax
	dec ebx
	call storeGridXY
	call floodFill
	ret
openBottomLeft ENDP

; ______________
openBottomCenter PROC
; ______________
	call getGridXY
	inc eax
	call storeGridXY
	call floodFill
	ret
openBottomCenter ENDP

; ______________
openBottomRight PROC
; ______________
	call getGridXY
	inc eax
	inc ebx
	call storeGridXY
	call floodFill
	ret
openBottomRight ENDP

; _______________
openRight PROC
; _______________
	call getGridXY
	inc ebx
	call storeGridXY
	call floodFill
	ret
openRight ENDP



; ______________________________________________
openCell PROC uses EAX EDI EDX
; delete current button / open current grid cell
; ______________________________________________
	call getButtonIndex
	mov eax, buttonIndex
	mov edi, OFFSET hButtons
	mov edx, [edi+eax]
	invoke DestroyWindow, edx
	ret
openCell ENDP

; _______________________________
getCellValue PROC uses ESI EAX
; Returns: grid cell value in ECX
; _______________________________
	mov esi, OFFSET grid
	call getGridXY
	call xyToIndex
	mov eax, gridIndex
	mov ecx, [esi+eax]
	ret
getCellValue ENDP

; ____________
getGridXY PROC
; ____________
	movzx eax, gridX
	movzx ebx, gridY
	ret
getGridXY ENDP

; ______________
storeGridXY PROC
; ______________
	mov gridX, ax
	mov gridY, bx
	ret
storeGridXY ENDP

; __________________________________
getButtonIndex PROC uses EAX EBX EDX
; converts existing grid index
; into corresponding button index.
; Uses: gridIndex, buttonIndex
; __________________________________
	mov eax, gridIndex
	mov bl, 4
	mul bl
	movzx eax, ax
	mov buttonIndex, eax
	ret
getButtonIndex ENDP

; ____________________________________
indexToXY PROC uses EAX EDX ECX
; this procedure converts a grid index
; into X & Y coordinates.
; Uses: EAX, EDX
; ____________________________________
	mov eax, gridIndex
	mov ecx, rowSize
	div cx ; AX = quotient (X), DX = remainder (Y)
	mov gridX, ax
	mov gridY, dx
	ret
indexToXY ENDP

; _____________________________
xyToIndex PROC uses ECX EDX
; this procedure converts
;  X & Y into grid index.
; Uses: EAX (X), EBX (Y)
; _____________________________
	mov ecx, rowSize
	mul cl          ; x * row size ->
	add eax, ebx    ; result + y = index
	mov gridIndex, eax
	ret
xyToIndex ENDP

; _______________________________________
checkVisited PROC uses ESI EBX EDX
; checks whether cell at index
; (stored in gridIndex) has been visited.
; Uses: EAX, visited, gridIndex
; _______________________________________
	mov esi, OFFSET visited
	mov edx, gridIndex
	add esi, edx
	mov al, [esi]
	ret
checkVisited ENDP

; _____________________________
visitCell PROC uses ESI EBX EAX
; visits a cell (at gridIndex).
; Uses: visited, gridIndex
; _____________________________
	mov esi, OFFSET visited
	mov eax, gridIndex
	add esi, eax
	mov bl, 1
	mov [esi], bl
	ret
visitCell ENDP

; ______________________________________________________________________________
; clearButtons destroys all grid buttons in the window by invoking DestroyWindow
; This procedure should be called when a game ends,
; Or when the reset button is clicked
; USES: EDI for location of hButtons array
;	  : ECX for length of hButtons (loop count)
; ______________________________________________________________________________
clearButtons PROC uses edi ecx
	mov edi, offset hButtons
	mov ecx, lengthof hButtons
	wipeButtons:
		mov edx, [edi]
		push ecx
		invoke DestroyWindow, edx
		pop ecx
		add edi, 4
		loop wipeButtons
	ret
clearButtons ENDP

;________________________________________
resetVisitedCells PROC uses ESI ECX EAX
; when game restarts, set values in
; array visited to back to default (100).
;________________________________________
	mov esi, OFFSET visited
	mov ecx, LENGTHOF visited
	mov al, 0
resetCells:
	mov [esi], al
	inc esi ; visited is of BYTE type
	loop resetCells
	ret
resetVisitedCells ENDP