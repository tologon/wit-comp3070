; All credit to KIP IRVINE for the Randomize, Random32, and RandomRange Procedures
; I have moved those procedures to this include file for compatibility with the MASM32 Libraries

	include \masm32\include\windows.inc
	include \masm32\include\user32.inc
	include \masm32\include\gdi32.inc
	include \masm32\include\kernel32.inc
	include \masm32\include\masm32.inc
	
	includelib \masm32\lib\user32.lib
	includelib \masm32\lib\gdi32.lib
	includelib \masm32\lib\kernel32.lib
	includelib \masm32\lib\masm32.lib
.data
sysTime SYSTEMTIME <> ; used to seed random number generator.

; access grid cells using the following: [base + index],
; where base is held in a base register
; and index is held in an index register.
; 48 is the ascii character for zero,
; by default cells in the grid will consist of zero.
grid	BYTE 9 DUP(48)
rowSize	= ($ - grid)
		BYTE 9 DUP(48)
		BYTE 9 DUP(48)
		BYTE 9 DUP(48)
		BYTE 9 DUP(48)
		BYTE 9 DUP(48)
		BYTE 9 DUP(48)
		BYTE 9 DUP(48)
		BYTE 9 DUP(48)

.code

; Places 10 mines randomly throughout the grid.
; Uses ecx for loop count, esi for location of grid, and eax for random number generation.
PlaceMines PROC uses ecx esi eax
	mov ecx, 10
	MineLayer:
		mov esi, offset grid
		mov eax, 81
		call RandomRange
		add esi, eax
		mov bl, [esi]
		cmp bl, 42
		je MineLayer
		call IncCells
		mov eax, 42
		mov [esi], al
		loop MineLayer
	ret
PlaceMines ENDP

; This procedure is called every time a new mine is placed, 
; and it will increment the value of surrounding cells by one.
; It also checks if the cell is at the edge of the grid, using division.
; If the cell is located at an edge, it will increment surroundings accordingly.
; When this procedure is called, esi should contain the location 
; of the center cell, which will contain a mine.
; eax will have the value between 0 and 80 generated by random range, 
; essentially it is the index of the cell.
IncCells PROC uses ebx edx
	mov bl, 9
	div bl				; puts quotient of esi / 9 into al and remainder into ah.
	mov edx, 1			; Required to increment cells by reference
	
		cmp al, 0
		je Lower	
	Upper:
		mov bl, [esi-9]
		cmp bl, 42
		je Lower
		add [esi-9], dl
	
	Lower:
		cmp al, 8
		je Left
		mov bl, [esi+9]
		cmp bl, 42
		je Left
		add [esi+9], dl
	
	Left:
		cmp ah, 0
		je Right
		
		cmp al, 0
		je Left2
		mov bl, [esi-10]
		cmp bl, 42
		je Left2
		add [esi-10], dl
		
		Left2:
		mov bl, [esi-1]
		cmp bl, 42
		je Left3
		add [esi-1], dl
		
		Left3:
		cmp al, 8
		je Right
		mov bl, [esi+8]
		cmp bl, 42
		je Right
		add [esi+8], dl
		
	
	Right:
		cmp ah, 8
		je Done
		
		cmp al,0
		je Right2
		mov bl, [esi-8]
		cmp bl, 42
		je Right2
		add [esi-8], dl
		
		Right2:
		mov bl, [esi+1]
		cmp bl, 42
		je Right3
		add [esi+1], dl
		
		Right3:
		cmp al, 8
		je Done
		mov bl, [esi+10]
		cmp bl, 42
		je Done
		add [esi+10], dl
	
	Done:
	ret
IncCells ENDP

; clearGrid Procedure will replace all cells in the grid with a zero.
; should be called before resetting the grid.
; input	: none
; output: the grid array will contain all zeroes (ascii characters, value == 48)
; uses	: eax to store '0' -- value replacing grid bytes.
;		: esi to store location of byte being changed
;		: ecx for loop count (length of grid array)
clearGrid PROC uses eax esi ecx
	mov esi, offset grid
	mov ecx, 81
	mov al, 48
	wipeGrid:
		mov [esi], al
		inc esi
		loop wipeGrid
	ret
clearGrid ENDP

;--------------------------------------------------------
Randomize PROC
;
; Re-seeds the random number generator with the current time
; in seconds. Calls GetSystemTime, which is accurate to 10ms.
; Receives: nothing
; Returns: nothing
; Last update: 09/06/2002
; AUTHOR: KIP IRVINE
;--------------------------------------------------------
	  pushad

	  INVOKE GetSystemTime,OFFSET sysTime
	  movzx eax,sysTime.wMilliseconds
	  mov   seed,eax

	  popad
	  ret
Randomize ENDP

;--------------------------------------------------------------
RandomRange PROC
;
; Returns an unsigned pseudo-random 32-bit integer
; in EAX, between 0 and n-1. Input parameter:
; EAX = n.
; Last update: 09/06/2002
; AUTHOR: KIP IRVINE
;--------------------------------------------------------------
	 push  ebx
	 push  edx

	 mov   ebx,eax  ; maximum value
	 call  Random32 ; eax = random number
	 mov   edx,0
	 div   ebx      ; divide by max value
	 mov   eax,edx  ; return the remainder

	 pop   edx
	 pop   ebx

	 ret
RandomRange ENDP

;--------------------------------------------------------------
Random32  PROC
;
; Generates an unsigned pseudo-random 32-bit integer
;   in the range 0 - FFFFFFFFh.
; Receives: nothing
; Returns: EAX = random integer
; Last update: 7/11/01
; AUTHOR: KIP IRVINE
;--------------------------------------------------------------
.data
seed  DWORD 1
.code
	  push  edx
	  mov   eax, 343FDh
	  imul  seed
	  add   eax, 269EC3h
	  mov   seed, eax    ; save the seed for the next call
	  ror   eax,8        ; rotate out the lowest digit (10/22/00)
	  pop   edx

	  ret
Random32  ENDP


.data
smiley DWORD ?
hButtons DWORD 81 DUP(?)
buttonIndex DWORD ?
gridIndex DWORD ?
gridX WORD ?
gridY WORD ?

originalEAX DWORD ?
cellsCount DWORD ?

; all existing indices fall in range between 0 and 80.
; therefore, if encountered 100, it means the end of visited indices
visited BYTE 81 DUP(100)

removedIndices BYTE 81 DUP(?)

.code
; _____________________________________________________________
removeButtons PROC uses EDI ESI EBX EDX ECX
; recursively removes buttons until it reaches
; the edges (the flood-fill algorithm).
; Uses: EAX (wParam), ESI (grid pointer), EDI (buttons pointer)
; _____________________________________________________________
	; pre-algorithm work
	mov originalEAX, eax
	mov esi, OFFSET grid     ; ESI holds reference to grid cells
	mov ebx, 4
	div bl
	movzx eax, al

	mov edi, OFFSET removedIndices
	mov cellsCount, 1
	add edi, cellsCount
	mov [edi], al
	
beginning:
	cmp cellsCount, 0
	je endProc

	mov edi, OFFSET removedIndices
	add edi, cellsCount
	mov al, [edi]
	movzx eax, al
	dec cellsCount ; decrement total # of available cells

	mov ecx, [esi+eax]
	cmp cl, '1'
	jge checkUpperLimit
	jl checkZero ; need to be careful for values of less than '0' in ASCII
	jmp beginning

checkUpperLimit:
	cmp cl, '8'
	jle openAndStop
	jmp beginning

checkZero:
	cmp cl, '0'
	je openMultipleCells
	jmp beginning

openMultipleCells:
	mov gridIndex, eax
	call getButtonIndex
	mov eax, buttonIndex
	mov edi, OFFSET hButtons ; EDI holds reference to buttons
	mov edx, [edi+eax]
	invoke DestroyWindow, edx
	call indexToXY
	call addSurroundingCells
	jmp beginning

openAndStop:
	mov gridIndex, eax
	call getButtonIndex
	mov eax, buttonIndex
	mov edi, OFFSET hButtons ; EDI holds reference to buttons
	mov edx, [edi+eax]
	invoke DestroyWindow, edx
	jmp beginning

endProc:
	mov eax, originalEAX
	ret
removeButtons ENDP

; __________________________________
getButtonIndex PROC uses EAX EBX EDX
; converts existing grid index
; into corresponding button index.
; Uses: gridIndex, buttonIndex
; __________________________________
	mov eax, gridIndex
	mov bl, 4
	mul bl
	movzx eax, ax
	mov buttonIndex, eax
	ret
getButtonIndex ENDP

; ____________________________________
indexToXY PROC uses EAX EDX ECX
; this procedure converts a grid index
; into X & Y coordinates.
; Uses: EAX, EDX
; ____________________________________
	mov eax, gridIndex
	mov ecx, rowSize
	div cx ; AX = quotient (X), DX = remainder (Y)
	mov gridX, ax
	mov gridY, dx
	ret
indexToXY ENDP

; _____________________________
xyToIndex PROC uses ECX EDX
; this procedure converts
;  X & Y into grid index.
; Uses: EAX (X), EBX (Y)
; _____________________________
	mov ecx, rowSize
	mul cl          ; x * row size ->
	add eax, ebx    ; result + y = index 
	mov gridIndex, eax
	ret
xyToIndex ENDP

; __________________________________________
addSurroundingCells PROC uses EAX EBX EDI
; this procedure adds surrounding cells
; into the stack and keeps the total number.
; Uses: EDX, stack
; __________________________________________
	; CURRENT CELL *********************************************************
	movzx eax, gridX
	movzx ebx, gridY
	cmp al, 0
	jl cell0           ; skip to next cell if x < 0
	cmp al, 8
	jg cell0           ; skip to next cell if x > 8
	cmp bl, 0
	jl cell0           ; skip to next cell if y < 0
	cmp bl, 8
	jg cell0           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je endCellsAdding  ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

cell0: ; TOP-LEFT CELL *****************************************************
	movzx eax, gridX
	dec eax
	movzx ebx, gridY
	dec ebx
	cmp al, 0
	jl cell1           ; skip to next cell if x < 0
	cmp al, 8
	jg cell1           ; skip to next cell if x > 8
	cmp bl, 0
	jl cell1           ; skip to next cell if y < 0
	cmp bl, 8
	jg cell1           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je cell1           ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

	mov edi, OFFSET removedIndices
	inc cellsCount
	add edi, cellsCount
	mov eax, gridIndex
	mov [edi], al
	
	
cell1: ; TOP-MIDDLE CELL ***************************************************
	movzx eax, gridX
	dec eax
	movzx ebx, gridY
	cmp al, 0
	jl cell2           ; skip to next cell if x < 0
	cmp al, 8
	jg cell2           ; skip to next cell if x > 8
	cmp bl, 0
	jl cell2           ; skip to next cell if y < 0
	cmp bl, 8
	jg cell2           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je cell2           ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

	mov edi, OFFSET removedIndices
	inc cellsCount
	add edi, cellsCount
	mov eax, gridIndex
	mov [edi], al

cell2: ; TOP-RIGHT CELL ****************************************************
	movzx eax, gridX
	dec eax
	movzx ebx, gridY
	inc ebx
	cmp al, 0
	jl cell3           ; skip to next cell if x < 0
	cmp al, 8
	jg cell3           ; skip to next cell if x > 8
	cmp bl, 0
	jl cell3           ; skip to next cell if y < 0
	cmp bl, 8
	jg cell3           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je cell3           ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

	mov edi, OFFSET removedIndices
	inc cellsCount
	add edi, cellsCount
	mov eax, gridIndex
	mov [edi], al

cell3: ; LEFT CELL *********************************************************
	movzx eax, gridX
	movzx ebx, gridY
	dec ebx
	cmp al, 0
	jl cell4           ; skip to next cell if x < 0
	cmp al, 8
	jg cell4           ; skip to next cell if x > 8
	cmp bl, 0
	jl cell4           ; skip to next cell if y < 0
	cmp bl, 8
	jg cell4           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je cell4           ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

	mov edi, OFFSET removedIndices
	inc cellsCount
	add edi, cellsCount
	mov eax, gridIndex
	mov [edi], al

cell4: ; RIGHT CELL ********************************************************
	movzx eax, gridX
	movzx ebx, gridY
	inc ebx
	cmp al, 0
	jl cell5           ; skip to next cell if x < 0
	cmp al, 8
	jg cell5           ; skip to next cell if x > 8
	cmp bl, 0
	jl cell5           ; skip to next cell if y < 0
	cmp bl, 8
	jg cell5           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je cell5           ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

	mov edi, OFFSET removedIndices
	inc cellsCount
	add edi, cellsCount
	mov eax, gridIndex
	mov [edi], al

cell5: ; BOTTOM-LEFT CELL **************************************************
	movzx eax, gridX
	inc eax
	movzx ebx, gridY
	dec ebx
	cmp al, 0
	jl cell6           ; skip to next cell if x < 0
	cmp al, 8
	jg cell6           ; skip to next cell if x > 8
	cmp bl, 0
	jl cell6           ; skip to next cell if y < 0
	cmp bl, 8
	jg cell6           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je cell6           ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

	mov edi, OFFSET removedIndices
	inc cellsCount
	add edi, cellsCount
	mov eax, gridIndex
	mov [edi], al

cell6: ; BOTTOM-MIDDLE CELL ************************************************
	movzx eax, gridX
	inc eax
	movzx ebx, gridY
	cmp al, 0
	jl cell7           ; skip to next cell if x < 0
	cmp al, 8
	jg cell7           ; skip to next cell if x > 8
	cmp bl, 0
	jl cell7           ; skip to next cell if y < 0
	cmp bl, 8
	jg cell7           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je cell7           ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

	mov edi, OFFSET removedIndices
	inc cellsCount
	add edi, cellsCount
	mov eax, gridIndex
	mov [edi], al

cell7: ; BOTTOM-RIGHT CELL *************************************************
	movzx eax, gridX
	inc eax
	movzx ebx, gridY
	inc ebx
	cmp al, 0
	jl endCellsAdding         ; skip to next cell if x < 0
	cmp al, 8
	jg endCellsAdding         ; skip to next cell if x > 8
	cmp bl, 0
	jl endCellsAdding         ; skip to next cell if y < 0
	cmp bl, 8
	jg endCellsAdding         ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je endCellsAdding         ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

	mov edi, OFFSET removedIndices
	inc cellsCount
	add edi, cellsCount
	mov eax, gridIndex
	mov [edi], al

endCellsAdding:
	ret
addSurroundingCells ENDP

; _______________________________________
checkVisited PROC uses ECX ESI EBX EDX
; checks whether cell at index
; (stored in gridIndex) has been visited.
; Uses: EAX, visited, gridIndex
; _______________________________________
	mov ecx, LENGTHOF visited
	mov esi, OFFSET visited
	mov edx, gridIndex
checkCells:
	mov ebx, [esi]
	cmp bl, 100
	je notVisitedAndExit  ; exit because match IS NOT found
	cmp ebx, edx
	je visitedAndExit     ; exit because match IS found
	inc esi
	loop checkCells
	
visitedAndExit:
	mov al, 1
	jmp endProc

notVisitedAndExit:
	mov al, 0
	jmp endProc

endProc:
	ret
checkVisited ENDP

; _____________________________
visitCell PROC uses ECX ESI EAX
; visits a cell (at gridIndex).
; Uses: visited, gridIndex
; _____________________________
	mov ecx, LENGTHOF visited
	mov esi, OFFSET visited
findCell:
	mov eax, [esi]
	cmp al, 100
	je visitAndQuit  ; quit because found the end of visited cells
	jmp continueFind

visitAndQuit:
	mov eax, gridIndex
	mov [esi], eax
	jmp endProc

continueFind:
	inc esi
	loop findCell

endProc:
	ret
visitCell ENDP

clearButtons PROC
	mov x, 35
	mov y, 30
	mov ButtonID, 0
	;push eax
	;push edi
	;push ecx
	;mov edi, offset smiley
	;mov edx, [edi]
	;invoke DestroyWindow, eax
	mov edi, offset hButtons
	mov ecx, lengthof hButtons
	wipeButtons:
		mov edx, [edi]
		push ecx
		invoke DestroyWindow, edx
		pop ecx
		add edi, 4
		loop wipeButtons
	;pop eax
	;pop ecx
	;pop edi
	ret
clearButtons ENDP