; All credit to KIP IRVINE for the Randomize, Random32, and RandomRange Procedures
; I have moved those procedures to this include file for compatibility with the MASM32 Libraries

	include \masm32\include\windows.inc
	include \masm32\include\user32.inc
	include \masm32\include\gdi32.inc
	include \masm32\include\kernel32.inc
	include \masm32\include\masm32.inc

	includelib \masm32\lib\user32.lib
	includelib \masm32\lib\gdi32.lib
	includelib \masm32\lib\kernel32.lib
	includelib \masm32\lib\masm32.lib
.data
sysTime SYSTEMTIME <> ; used to seed random number generator.

; access grid cells using the following: [base + index],
; where base is held in a base register
; and index is held in an index register.
; 48 is the ascii character for zero,
; by default cells in the grid will consist of zero.
grid	BYTE 9 DUP('0')
rowSize	= ($ - grid)
		BYTE 9 DUP('0')
		BYTE 9 DUP('0')
		BYTE 9 DUP('0')
		BYTE 9 DUP('0')
		BYTE 9 DUP('0')
		BYTE 9 DUP('0')
		BYTE 9 DUP('0')
		BYTE 9 DUP('0')

.code

; PlaceMines places 10 mines randomly throughout the grid.
; INPUT		: N/A
; OUTPUT	: 10 random cells in grid are replaced with an * designating a mine
; USES		: ECX for loop count
;			: ESI for location of grid
;			: EAX for random number generation
PlaceMines PROC uses ecx esi eax
	mov ecx, 10
	MineLayer:
		mov esi, offset grid
		mov eax, 81
		call RandomRange
		add esi, eax
		mov bl, [esi]
		cmp bl, '*'
		je MineLayer
		call IncCells
		mov eax, '*'
		mov [esi], al
		loop MineLayer
	ret
PlaceMines ENDP

; IncCells is Called every time a new mine is placed.
; Increments the value of surrounding cells by one.
; Also checks if the cell is at the edge of the grid, using division.
; If the cell is located at an edge, it will ignore cells that cross boundaries
; INPUT		: EAX will have the cell index (generated by RandomRange) (0-80)
;			: ESI will have the memory location of the mine cell.
; OUTPUT	: grid will be modified so that the value of each cell surrounding
;			: target cell is increased by one.
;			: EAX divided by 9: AH contains column location of the cell (x).
;			: AL contains the row location of the cell (y).
; USES		: EBX is used for division operation,
;			:	and checking values of surrounding cells.
;			: EDX is used to increment cells by reference.
IncCells PROC uses ebx edx
	mov bl, 9
	div bl				; puts quotient of index / 9 into al, remainder into ah
	mov dl, 1

		cmp al, 0		; If target cell is in top row
		je Lower		; Ignore top
	Upper:
		mov bl, [esi-9]
		cmp bl, '*'
		je Lower
		add [esi-9], dl

	Lower:
		cmp al, 8
		je Left
		mov bl, [esi+9]
		cmp bl, '*'
		je Left
		add [esi+9], dl

	Left:
		cmp ah, 0
		je Right

		cmp al, 0
		je Left2
		mov bl, [esi-10]
		cmp bl, '*'
		je Left2
		add [esi-10], dl

		Left2:
		mov bl, [esi-1]
		cmp bl, '*'
		je Left3
		add [esi-1], dl

		Left3:
		cmp al, 8
		je Right
		mov bl, [esi+8]
		cmp bl, '*'
		je Right
		add [esi+8], dl


	Right:
		cmp ah, 8
		je Done

		cmp al,0
		je Right2
		mov bl, [esi-8]
		cmp bl, '*'
		je Right2
		add [esi-8], dl

		Right2:
		mov bl, [esi+1]
		cmp bl, '*'
		je Right3
		add [esi+1], dl

		Right3:
		cmp al, 8
		je Done
		mov bl, [esi+10]
		cmp bl, '*'
		je Done
		add [esi+10], dl

	Done:
	ret
IncCells ENDP

; clearGrid will replace all cells in the grid with a zero.
; Useful for resetting the grid -- call this before placing new mines.
; INPUT	: none
; OUTPUT: the grid array will contain all zeroes (ascii characters, value == 48)
; USES	: eax to store '0' -- value replacing grid bytes.
;		: esi to store location of byte being changed
;		: ecx for loop count (length of grid array)
clearGrid PROC uses eax esi ecx
	mov esi, offset grid
	mov ecx, 81
	mov al, '0'
	wipeGrid:
		mov [esi], al
		inc esi
		loop wipeGrid
	ret
clearGrid ENDP

;--------------------------------------------------------
Randomize PROC
;
; Re-seeds the random number generator with the current time
; in seconds. Calls GetSystemTime, which is accurate to 10ms.
; Receives: nothing
; Returns: nothing
; Last update: 09/06/2002
; AUTHOR: KIP IRVINE
;--------------------------------------------------------
	  pushad

	  INVOKE GetSystemTime,OFFSET sysTime
	  movzx eax,sysTime.wMilliseconds
	  mov   seed,eax

	  popad
	  ret
Randomize ENDP

;--------------------------------------------------------------
RandomRange PROC
;
; Returns an unsigned pseudo-random 32-bit integer
; in EAX, between 0 and n-1. Input parameter:
; EAX = n.
; Last update: 09/06/2002
; AUTHOR: KIP IRVINE
;--------------------------------------------------------------
	 push  ebx
	 push  edx

	 mov   ebx,eax  ; maximum value
	 call  Random32 ; eax = random number
	 mov   edx,0
	 div   ebx      ; divide by max value
	 mov   eax,edx  ; return the remainder

	 pop   edx
	 pop   ebx

	 ret
RandomRange ENDP

;--------------------------------------------------------------
Random32  PROC
;
; Generates an unsigned pseudo-random 32-bit integer
;   in the range 0 - FFFFFFFFh.
; Receives: nothing
; Returns: EAX = random integer
; Last update: 7/11/01
; AUTHOR: KIP IRVINE
;--------------------------------------------------------------
.data
seed  DWORD 1
.code
	  push  edx
	  mov   eax, 343FDh
	  imul  seed
	  add   eax, 269EC3h
	  mov   seed, eax    ; save the seed for the next call
	  ror   eax,8        ; rotate out the lowest digit (10/22/00)
	  pop   edx

	  ret
Random32  ENDP


.data
smiley DWORD ?
hButtons DWORD 81 DUP(?)
buttonIndex DWORD ?
gridIndex DWORD ?
gridX WORD ?
gridY WORD ?

originalEAX DWORD ?
removedIndex DWORD ? ; current index of a item in removedIndices array
removedCount DWORD ? ; current count of items in removedIndices array

; all existing indices fall in range between 0 and 80.
; therefore, if encountered 100, it means the end of visited indices
visited BYTE 81 DUP(100)

removedIndices BYTE 81 DUP(-1)

.code
; ________________
removeButtons PROC
; ________________
	mov originalEAX, eax
	call setupAlgorithm ; do initial setup of flood-fill algorithm
	call floodFill      ; recursively call flood-fill using values of gridX and gridY
	mov eax, originalEAX
	ret
removeButtons ENDP

;_______________________________
setupAlgorithm PROC uses ESI EBX
;_______________________________
	mov esi, OFFSET grid
	mov ebx, 4
	div bl
	movzx eax, al      ; grid index
	mov gridIndex, eax ; save grid index
	call indexToXY     ; turn grid index into X and Y values
	ret
setupAlgorithm ENDP

; _____________________________________
floodFill PROC uses EAX EBX ECX EDI EDX
; _____________________________________
	call storeXYinRegisters
	cmp al, 0
	jl endProc         ; return if x < 0
	cmp al, 8
	jg endProc         ; return if x > 8
	cmp bl, 0
	jl endProc         ; return if y < 0
	cmp bl, 8
	jg endProc         ; return if y > 8
	call xyToIndex     ; stores new index in gridIndex
	;call checkVisited  ; returns answer (index VISITED = 1 or NOT VISITED = 0) in AL
	;cmp al, 1          ; if visited index
	;je endProc         ; already visited, skip to next cell
	;call visitCell     ; not visited, visit that cell

	call getCellValue
	cmp cl, '*'
	je explosion
	cmp cl, '1'
	jge checkUpperLimit
	cmp cl, '0'
	je openMultipleCells
	jmp endProc

explosion:
	call resetVisitedCells
	call resetRemovedIndices
	call clearButtons
	jmp endProc

checkUpperLimit:
	cmp cl, '8'
	jle openAndStop
	jmp endProc

openAndStop:
	call openCell
	jmp endProc

openMultipleCells:
	call openCell

	call storeXYinRegisters
	push ax
	push bx
	push ax
	push bx
	push ax
	push bx
	call openTopLeft

	pop bx
	pop ax
	call openTopCenter

	pop bx
	pop ax
	call openTopRight
	
	pop bx
	pop ax
	call openLeft
	
	;pop bx
	;pop ax
	;call openRight
	
	;pop bx
	;pop ax
	;call openBottomLeft

	jmp endProc

endProc:
	ret
floodFill ENDP

; ______________
openTopLeft PROC
; ______________
	;call storeXYinRegisters
	dec eax
	dec ebx
	call storeXYinVariables
	;mov gridX, ax
	;mov gridY, bx
	call floodFill
	ret
openTopLeft ENDP

; ________________
openTopCenter PROC
; ________________
	dec eax
	call storeXYinVariables
	;mov gridX, ax
	;mov gridY, bx
	call floodFill
	ret
openTopCenter ENDP

; ______________
openTopRight PROC
; ______________
;	call storeXYinRegisters
	dec eax
	inc ebx
	call storeXYinVariables
	;mov gridX, ax
	;mov gridY, bx
	call floodFill
	ret
openTopRight ENDP

; ______________
openLeft PROC
; ______________
;	call storeXYinRegisters
	dec ebx
	call storeXYinVariables
	;mov gridX, ax
	;mov gridY, bx
	call floodFill
	ret
openLeft ENDP

; ______________
openRight PROC
; ______________
;	call storeXYinRegisters
	inc ebx
	call storeXYinVariables
	;mov gridX, ax
	;mov gridY, bx
	call floodFill
	ret
openRight ENDP

; ______________
openBottomLeft PROC
; ______________
;	call storeXYinRegisters
	dec ebx
	inc eax
	call storeXYinVariables
	;mov gridX, ax
	;mov gridY, bx
	call floodFill
	ret
openBottomLeft ENDP

; ______________________________________________
openCell PROC uses EAX EDI EDX
; delete current button / open current grid cell
; ______________________________________________
	call getButtonIndex
	mov eax, buttonIndex
	mov edi, OFFSET hButtons
	mov edx, [edi+eax]
	invoke DestroyWindow, edx
	ret
openCell ENDP

; _______________________________
getCellValue PROC uses ESI EAX
; Returns: grid cell value in ECX
; _______________________________
	mov esi, OFFSET grid
	call storeXYinRegisters
	call xyToIndex
	mov eax, gridIndex
	mov ecx, [esi+eax]
	ret
getCellValue ENDP

; _____________________
storeXYinRegisters PROC
; _____________________
	movzx eax, gridX
	movzx ebx, gridY
	ret
storeXYinRegisters ENDP

; _____________________
storeXYinVariables PROC
; _____________________
	mov gridX, ax
	mov gridY, bx
	ret
storeXYinVariables ENDP

; _____________________________________________________________
oldRemoval PROC uses EDI ESI EBX EDX ECX
; recursively removes buttons until it reaches
; the edges (the flood-fill algorithm).
; Uses: EAX (wParam), ESI (grid pointer), EDI (buttons pointer)
; _____________________________________________________________
	; pre-algorithm work
	mov originalEAX, eax
	mov esi, OFFSET grid     ; ESI holds reference to grid cells
	mov ebx, 4
	div bl
	movzx eax, al

	mov removedIndex, 0
	mov removedCount, 1
	mov edi, OFFSET removedIndices
	mov [edi], al ; store button index (most likely, passed via mouse click)

beginning:
	mov ebx, removedIndex
	mov ebx, removedCount
	cmp removedIndex, ebx
	jge endProc ; end if (item index) >= (items count)

	mov edi, OFFSET removedIndices
	add edi, removedIndex
	mov al, [edi] ; get button index at item index
	movzx eax, al
	inc removedIndex ; increment item index

	mov ecx, [esi+eax]
	cmp cl, '1'
	jge checkUpperLimit
	cmp cl, '*'
	je explosion
	jg checkZero ; need to be careful for values other than '0' in ASCII
	jmp beginning

checkUpperLimit:
	cmp cl, '8'
	jle openAndStop
	jmp beginning

explosion:
	call resetVisitedCells
	call resetRemovedIndices
	call clearButtons
	jmp endProc

checkZero:
	cmp cl, '0'
	je openMultipleCells
	jmp beginning

openMultipleCells:
	mov gridIndex, eax
	call getButtonIndex
	mov eax, buttonIndex
	mov edi, OFFSET hButtons
	mov edx, [edi+eax]
	invoke DestroyWindow, edx
	call indexToXY
	call addSurroundingCells
	jmp beginning

openAndStop:
	mov gridIndex, eax
	call getButtonIndex
	mov eax, buttonIndex
	mov edi, OFFSET hButtons
	mov edx, [edi+eax]
	invoke DestroyWindow, edx
	jmp beginning

endProc:
	mov eax, originalEAX
	ret
oldRemoval ENDP

; __________________________________
getButtonIndex PROC uses EAX EBX EDX
; converts existing grid index
; into corresponding button index.
; Uses: gridIndex, buttonIndex
; __________________________________
	mov eax, gridIndex
	mov bl, 4
	mul bl
	movzx eax, ax
	mov buttonIndex, eax
	ret
getButtonIndex ENDP

; ____________________________________
indexToXY PROC uses EAX EDX ECX
; this procedure converts a grid index
; into X & Y coordinates.
; Uses: EAX, EDX
; ____________________________________
	mov eax, gridIndex
	mov ecx, rowSize
	div cx ; AX = quotient (X), DX = remainder (Y)
	mov gridX, ax
	mov gridY, dx
	ret
indexToXY ENDP

; _____________________________
xyToIndex PROC uses ECX EDX
; this procedure converts
;  X & Y into grid index.
; Uses: EAX (X), EBX (Y)
; _____________________________
	mov ecx, rowSize
	mul cl          ; x * row size ->
	add eax, ebx    ; result + y = index
	mov gridIndex, eax
	ret
xyToIndex ENDP

; __________________________________________
addSurroundingCells PROC uses EAX EBX EDI
; this procedure adds surrounding cells
; into the stack and keeps the total number.
; Uses: EDX, stack
; __________________________________________
cell0: ; TOP-LEFT CELL *****************************************************
	movzx eax, gridX
	dec eax
	movzx ebx, gridY
	dec ebx
	cmp al, 0
	jl cell1           ; skip to next cell if x < 0
	cmp al, 8
	jg cell1           ; skip to next cell if x > 8
	cmp bl, 0
	jl cell1           ; skip to next cell if y < 0
	cmp bl, 8
	jg cell1           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je endCellsAdding         ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

	mov edi, OFFSET removedIndices
	add edi, removedCount
	mov eax, gridIndex
	mov [edi], al
	inc removedCount


cell1: ; TOP-MIDDLE CELL ***************************************************
	movzx eax, gridX
	dec eax
	movzx ebx, gridY
	cmp al, 0
	jl cell2           ; skip to next cell if x < 0
	cmp al, 8
	jg cell2           ; skip to next cell if x > 8
	cmp bl, 0
	jl cell2           ; skip to next cell if y < 0
	cmp bl, 8
	jg cell2           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je endCellsAdding         ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

	mov edi, OFFSET removedIndices
	add edi, removedCount
	mov eax, gridIndex
	mov [edi], al
	inc removedCount

cell2: ; TOP-RIGHT CELL ****************************************************
	movzx eax, gridX
	dec eax
	movzx ebx, gridY
	inc ebx
	cmp al, 0
	jl cell3           ; skip to next cell if x < 0
	cmp al, 8
	jg cell3           ; skip to next cell if x > 8
	cmp bl, 0
	jl cell3           ; skip to next cell if y < 0
	cmp bl, 8
	jg cell3           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je endCellsAdding         ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

	mov edi, OFFSET removedIndices
	add edi, removedCount
	mov eax, gridIndex
	mov [edi], al
	inc removedCount

cell3: ; LEFT CELL *********************************************************
	movzx eax, gridX
	movzx ebx, gridY
	dec ebx
	cmp al, 0
	jl cell4           ; skip to next cell if x < 0
	cmp al, 8
	jg cell4           ; skip to next cell if x > 8
	cmp bl, 0
	jl cell4           ; skip to next cell if y < 0
	cmp bl, 8
	jg cell4           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je endCellsAdding         ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

	mov edi, OFFSET removedIndices
	add edi, removedCount
	mov eax, gridIndex
	mov [edi], al
	inc removedCount

cell4: ; RIGHT CELL ********************************************************
	movzx eax, gridX
	movzx ebx, gridY
	inc ebx
	cmp al, 0
	jl cell5           ; skip to next cell if x < 0
	cmp al, 8
	jg cell5           ; skip to next cell if x > 8
	cmp bl, 0
	jl cell5           ; skip to next cell if y < 0
	cmp bl, 8
	jg cell5           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je endCellsAdding         ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

	mov edi, OFFSET removedIndices
	add edi, removedCount
	mov eax, gridIndex
	mov [edi], al
	inc removedCount

cell5: ; BOTTOM-LEFT CELL **************************************************
	movzx eax, gridX
	inc eax
	movzx ebx, gridY
	dec ebx
	cmp al, 0
	jl cell6           ; skip to next cell if x < 0
	cmp al, 8
	jg cell6           ; skip to next cell if x > 8
	cmp bl, 0
	jl cell6           ; skip to next cell if y < 0
	cmp bl, 8
	jg cell6           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je endCellsAdding         ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

	mov edi, OFFSET removedIndices
	add edi, removedCount
	mov eax, gridIndex
	mov [edi], al
	inc removedCount

cell6: ; BOTTOM-MIDDLE CELL ************************************************
	movzx eax, gridX
	inc eax
	movzx ebx, gridY
	cmp al, 0
	jl cell7           ; skip to next cell if x < 0
	cmp al, 8
	jg cell7           ; skip to next cell if x > 8
	cmp bl, 0
	jl cell7           ; skip to next cell if y < 0
	cmp bl, 8
	jg cell7           ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je endCellsAdding         ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

	mov edi, OFFSET removedIndices
	add edi, removedCount
	mov eax, gridIndex
	mov [edi], al
	inc removedCount

cell7: ; BOTTOM-RIGHT CELL *************************************************
	movzx eax, gridX
	inc eax
	movzx ebx, gridY
	inc ebx
	cmp al, 0
	jl endCellsAdding  ; skip to next cell if x < 0
	cmp al, 8
	jg endCellsAdding  ; skip to next cell if x > 8
	cmp bl, 0
	jl endCellsAdding  ; skip to next cell if y < 0
	cmp bl, 8
	jg endCellsAdding  ; skip to next cell if y > 8
	call xyToIndex     ; stores new index in gridIndex
	call checkVisited  ; returns answer (index VISITED or NOT VISITED) in AL
	cmp al, 1          ; if visited index
	je endCellsAdding         ; already visited, skip to next cell
	call visitCell     ; not visited, visit that cell & add it to stack

	mov edi, OFFSET removedIndices
	add edi, removedCount
	mov eax, gridIndex
	mov [edi], al
	inc removedCount

endCellsAdding:
	ret
addSurroundingCells ENDP

; _______________________________________
checkVisited PROC uses ECX ESI EBX EDX
; checks whether cell at index
; (stored in gridIndex) has been visited.
; Uses: EAX, visited, gridIndex
; _______________________________________
	mov ecx, LENGTHOF visited
	mov esi, OFFSET visited
	mov edx, gridIndex
	mov al, 1
checkCells:
	mov ebx, [esi]
	cmp bl, 100
	je notVisitedAndExit  ; exit because match IS NOT found
	cmp ebx, edx
	je visitedAndExit     ; exit because match IS found
	jmp endOfLoop

visitedAndExit:
	mov al, 1
	jmp endProc

notVisitedAndExit:
	mov al, 0
	jmp endProc

endOfLoop:
	inc esi
	loop checkCells

endProc:
	mov al, 0
	ret
checkVisited ENDP

; _____________________________
visitCell PROC uses ECX ESI EAX
; visits a cell (at gridIndex).
; Uses: visited, gridIndex
; _____________________________
	mov ecx, LENGTHOF visited
	mov esi, OFFSET visited
findCell:
	mov eax, [esi]
	cmp al, 100
	je visitAndQuit  ; quit because found the end of visited cells
	jmp continueFind

visitAndQuit:
	mov eax, gridIndex
	mov [esi], al
	jmp endProc

continueFind:
	inc esi
	loop findCell

endProc:
	ret
visitCell ENDP

; ______________________________________________________________________________
; clearButtons destroys all grid buttons in the window by invoking DestroyWindow
; This procedure should be called when a game ends,
; Or when the reset button is clicked
; USES: EDI for location of hButtons array
;	  : ECX for length of hButtons (loop count)
; ______________________________________________________________________________
clearButtons PROC uses edi ecx
	mov edi, offset hButtons
	mov ecx, lengthof hButtons
	wipeButtons:
		mov edx, [edi]
		push ecx
		invoke DestroyWindow, edx
		pop ecx
		add edi, 4
		loop wipeButtons
	ret
clearButtons ENDP

;________________________________________
resetVisitedCells PROC uses ESI ECX EAX
; when game restarts, set values in
; array visited to back to default (100).
;________________________________________
	mov esi, OFFSET visited
	mov ecx, LENGTHOF visited
	mov al, 100
resetCells:
	mov [esi], al
	inc esi ; visited is of BYTE type
	loop resetCells
	ret
resetVisitedCells ENDP

; _______________________________________
resetRemovedIndices PROC uses ESI ECX EAX
; _______________________________________
	mov esi, OFFSET removedIndices
	mov ecx, LENGTHOF removedIndices
	mov al, -1
resetIndices:
	mov [esi], al
	inc esi
	loop resetIndices
	ret
resetRemovedIndices ENDP